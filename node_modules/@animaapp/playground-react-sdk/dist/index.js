var Js = Object.defineProperty, Xs = Object.defineProperties;
var Zs = Object.getOwnPropertyDescriptors;
var Ct = Object.getOwnPropertySymbols;
var Ir = Object.prototype.hasOwnProperty, Mr = Object.prototype.propertyIsEnumerable;
var jr = (t) => {
  throw TypeError(t);
}, kr = Math.pow, Ar = (t, e, r) => e in t ? Js(t, e, { enumerable: !0, configurable: !0, writable: !0, value: r }) : t[e] = r, b = (t, e) => {
  for (var r in e || (e = {}))
    Ir.call(e, r) && Ar(t, r, e[r]);
  if (Ct)
    for (var r of Ct(e))
      Mr.call(e, r) && Ar(t, r, e[r]);
  return t;
}, j = (t, e) => Xs(t, Zs(e));
var qr = (t, e) => {
  var r = {};
  for (var s in t)
    Ir.call(t, s) && e.indexOf(s) < 0 && (r[s] = t[s]);
  if (t != null && Ct)
    for (var s of Ct(t))
      e.indexOf(s) < 0 && Mr.call(t, s) && (r[s] = t[s]);
  return r;
};
var Vt = (t, e, r) => e.has(t) || jr("Cannot " + r);
var i = (t, e, r) => (Vt(t, e, "read from private field"), r ? r.call(t) : e.get(t)), y = (t, e, r) => e.has(t) ? jr("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r), f = (t, e, r, s) => (Vt(t, e, "write to private field"), s ? s.call(t, r) : e.set(t, r), r), w = (t, e, r) => (Vt(t, e, "access private method"), r);
var Pt = (t, e, r, s) => ({
  set _(a) {
    f(t, e, a, r);
  },
  get _() {
    return i(t, e, s);
  }
});
var H = (t, e, r) => new Promise((s, a) => {
  var o = (h) => {
    try {
      l(r.next(h));
    } catch (E) {
      a(E);
    }
  }, u = (h) => {
    try {
      l(r.throw(h));
    } catch (E) {
      a(E);
    }
  }, l = (h) => h.done ? s(h.value) : Promise.resolve(h.value).then(o, u);
  l((r = r.apply(t, e)).next());
});
import * as z from "react";
import cs, { useEffect as ei, useCallback as Qr } from "react";
var _t = { exports: {} }, ft = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ur;
function ti() {
  if (Ur) return ft;
  Ur = 1;
  var t = cs, e = Symbol.for("react.element"), r = Symbol.for("react.fragment"), s = Object.prototype.hasOwnProperty, a = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, o = { key: !0, ref: !0, __self: !0, __source: !0 };
  function u(l, h, E) {
    var g, p = {}, S = null, R = null;
    E !== void 0 && (S = "" + E), h.key !== void 0 && (S = "" + h.key), h.ref !== void 0 && (R = h.ref);
    for (g in h) s.call(h, g) && !o.hasOwnProperty(g) && (p[g] = h[g]);
    if (l && l.defaultProps) for (g in h = l.defaultProps, h) p[g] === void 0 && (p[g] = h[g]);
    return { $$typeof: e, type: l, key: S, ref: R, props: p, _owner: a.current };
  }
  return ft.Fragment = r, ft.jsx = u, ft.jsxs = u, ft;
}
var dt = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Kr;
function ri() {
  return Kr || (Kr = 1, process.env.NODE_ENV !== "production" && function() {
    var t = cs, e = Symbol.for("react.element"), r = Symbol.for("react.portal"), s = Symbol.for("react.fragment"), a = Symbol.for("react.strict_mode"), o = Symbol.for("react.profiler"), u = Symbol.for("react.provider"), l = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), E = Symbol.for("react.suspense"), g = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), S = Symbol.for("react.lazy"), R = Symbol.for("react.offscreen"), Q = Symbol.iterator, P = "@@iterator";
    function O(n) {
      if (n === null || typeof n != "object")
        return null;
      var c = Q && n[Q] || n[P];
      return typeof c == "function" ? c : null;
    }
    var D = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function _(n) {
      {
        for (var c = arguments.length, d = new Array(c > 1 ? c - 1 : 0), m = 1; m < c; m++)
          d[m - 1] = arguments[m];
        W("error", n, d);
      }
    }
    function W(n, c, d) {
      {
        var m = D.ReactDebugCurrentFrame, x = m.getStackAddendum();
        x !== "" && (c += "%s", d = d.concat([x]));
        var I = d.map(function(F) {
          return String(F);
        });
        I.unshift("Warning: " + c), Function.prototype.apply.call(console[n], console, I);
      }
    }
    var v = !1, k = !1, $ = !1, te = !1, K = !1, le;
    le = Symbol.for("react.module.reference");
    function N(n) {
      return !!(typeof n == "string" || typeof n == "function" || n === s || n === o || K || n === a || n === E || n === g || te || n === R || v || k || $ || typeof n == "object" && n !== null && (n.$$typeof === S || n.$$typeof === p || n.$$typeof === u || n.$$typeof === l || n.$$typeof === h || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      n.$$typeof === le || n.getModuleId !== void 0));
    }
    function M(n, c, d) {
      var m = n.displayName;
      if (m)
        return m;
      var x = c.displayName || c.name || "";
      return x !== "" ? d + "(" + x + ")" : d;
    }
    function Y(n) {
      return n.displayName || "Context";
    }
    function G(n) {
      if (n == null)
        return null;
      if (typeof n.tag == "number" && _("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof n == "function")
        return n.displayName || n.name || null;
      if (typeof n == "string")
        return n;
      switch (n) {
        case s:
          return "Fragment";
        case r:
          return "Portal";
        case o:
          return "Profiler";
        case a:
          return "StrictMode";
        case E:
          return "Suspense";
        case g:
          return "SuspenseList";
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case l:
            var c = n;
            return Y(c) + ".Consumer";
          case u:
            var d = n;
            return Y(d._context) + ".Provider";
          case h:
            return M(n, n.render, "ForwardRef");
          case p:
            var m = n.displayName || null;
            return m !== null ? m : G(n.type) || "Memo";
          case S: {
            var x = n, I = x._payload, F = x._init;
            try {
              return G(F(I));
            } catch (C) {
              return null;
            }
          }
        }
      return null;
    }
    var xe = Object.assign, ct = 0, lr, hr, fr, dr, yr, pr, vr;
    function mr() {
    }
    mr.__reactDisabledLog = !0;
    function Os() {
      {
        if (ct === 0) {
          lr = console.log, hr = console.info, fr = console.warn, dr = console.error, yr = console.group, pr = console.groupCollapsed, vr = console.groupEnd;
          var n = {
            configurable: !0,
            enumerable: !0,
            value: mr,
            writable: !0
          };
          Object.defineProperties(console, {
            info: n,
            log: n,
            warn: n,
            error: n,
            group: n,
            groupCollapsed: n,
            groupEnd: n
          });
        }
        ct++;
      }
    }
    function Cs() {
      {
        if (ct--, ct === 0) {
          var n = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: xe({}, n, {
              value: lr
            }),
            info: xe({}, n, {
              value: hr
            }),
            warn: xe({}, n, {
              value: fr
            }),
            error: xe({}, n, {
              value: dr
            }),
            group: xe({}, n, {
              value: yr
            }),
            groupCollapsed: xe({}, n, {
              value: pr
            }),
            groupEnd: xe({}, n, {
              value: vr
            })
          });
        }
        ct < 0 && _("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var kt = D.ReactCurrentDispatcher, qt;
    function wt(n, c, d) {
      {
        if (qt === void 0)
          try {
            throw Error();
          } catch (x) {
            var m = x.stack.trim().match(/\n( *(at )?)/);
            qt = m && m[1] || "";
          }
        return `
` + qt + n;
      }
    }
    var Qt = !1, Rt;
    {
      var Ps = typeof WeakMap == "function" ? WeakMap : Map;
      Rt = new Ps();
    }
    function gr(n, c) {
      if (!n || Qt)
        return "";
      {
        var d = Rt.get(n);
        if (d !== void 0)
          return d;
      }
      var m;
      Qt = !0;
      var x = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var I;
      I = kt.current, kt.current = null, Os();
      try {
        if (c) {
          var F = function() {
            throw Error();
          };
          if (Object.defineProperty(F.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(F, []);
            } catch (re) {
              m = re;
            }
            Reflect.construct(n, [], F);
          } else {
            try {
              F.call();
            } catch (re) {
              m = re;
            }
            n.call(F.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re) {
            m = re;
          }
          n();
        }
      } catch (re) {
        if (re && m && typeof re.stack == "string") {
          for (var C = re.stack.split(`
`), J = m.stack.split(`
`), U = C.length - 1, L = J.length - 1; U >= 1 && L >= 0 && C[U] !== J[L]; )
            L--;
          for (; U >= 1 && L >= 0; U--, L--)
            if (C[U] !== J[L]) {
              if (U !== 1 || L !== 1)
                do
                  if (U--, L--, L < 0 || C[U] !== J[L]) {
                    var ne = `
` + C[U].replace(" at new ", " at ");
                    return n.displayName && ne.includes("<anonymous>") && (ne = ne.replace("<anonymous>", n.displayName)), typeof n == "function" && Rt.set(n, ne), ne;
                  }
                while (U >= 1 && L >= 0);
              break;
            }
        }
      } finally {
        Qt = !1, kt.current = I, Cs(), Error.prepareStackTrace = x;
      }
      var Ye = n ? n.displayName || n.name : "", Ae = Ye ? wt(Ye) : "";
      return typeof n == "function" && Rt.set(n, Ae), Ae;
    }
    function _s(n, c, d) {
      return gr(n, !1);
    }
    function Ts(n) {
      var c = n.prototype;
      return !!(c && c.isReactComponent);
    }
    function St(n, c, d) {
      if (n == null)
        return "";
      if (typeof n == "function")
        return gr(n, Ts(n));
      if (typeof n == "string")
        return wt(n);
      switch (n) {
        case E:
          return wt("Suspense");
        case g:
          return wt("SuspenseList");
      }
      if (typeof n == "object")
        switch (n.$$typeof) {
          case h:
            return _s(n.render);
          case p:
            return St(n.type, c, d);
          case S: {
            var m = n, x = m._payload, I = m._init;
            try {
              return St(I(x), c, d);
            } catch (F) {
            }
          }
        }
      return "";
    }
    var lt = Object.prototype.hasOwnProperty, br = {}, Er = D.ReactDebugCurrentFrame;
    function Ot(n) {
      if (n) {
        var c = n._owner, d = St(n.type, n._source, c ? c.type : null);
        Er.setExtraStackFrame(d);
      } else
        Er.setExtraStackFrame(null);
    }
    function Fs(n, c, d, m, x) {
      {
        var I = Function.call.bind(lt);
        for (var F in n)
          if (I(n, F)) {
            var C = void 0;
            try {
              if (typeof n[F] != "function") {
                var J = Error((m || "React class") + ": " + d + " type `" + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof n[F] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw J.name = "Invariant Violation", J;
              }
              C = n[F](c, F, m, d, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (U) {
              C = U;
            }
            C && !(C instanceof Error) && (Ot(x), _("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", m || "React class", d, F, typeof C), Ot(null)), C instanceof Error && !(C.message in br) && (br[C.message] = !0, Ot(x), _("Failed %s type: %s", d, C.message), Ot(null));
          }
      }
    }
    var Ds = Array.isArray;
    function Ut(n) {
      return Ds(n);
    }
    function xs(n) {
      {
        var c = typeof Symbol == "function" && Symbol.toStringTag, d = c && n[Symbol.toStringTag] || n.constructor.name || "Object";
        return d;
      }
    }
    function As(n) {
      try {
        return wr(n), !1;
      } catch (c) {
        return !0;
      }
    }
    function wr(n) {
      return "" + n;
    }
    function Rr(n) {
      if (As(n))
        return _("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", xs(n)), wr(n);
    }
    var ht = D.ReactCurrentOwner, Is = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Sr, Or, Kt;
    Kt = {};
    function Ms(n) {
      if (lt.call(n, "ref")) {
        var c = Object.getOwnPropertyDescriptor(n, "ref").get;
        if (c && c.isReactWarning)
          return !1;
      }
      return n.ref !== void 0;
    }
    function js(n) {
      if (lt.call(n, "key")) {
        var c = Object.getOwnPropertyDescriptor(n, "key").get;
        if (c && c.isReactWarning)
          return !1;
      }
      return n.key !== void 0;
    }
    function ks(n, c) {
      if (typeof n.ref == "string" && ht.current && c && ht.current.stateNode !== c) {
        var d = G(ht.current.type);
        Kt[d] || (_('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', G(ht.current.type), n.ref), Kt[d] = !0);
      }
    }
    function qs(n, c) {
      {
        var d = function() {
          Sr || (Sr = !0, _("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", c));
        };
        d.isReactWarning = !0, Object.defineProperty(n, "key", {
          get: d,
          configurable: !0
        });
      }
    }
    function Qs(n, c) {
      {
        var d = function() {
          Or || (Or = !0, _("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", c));
        };
        d.isReactWarning = !0, Object.defineProperty(n, "ref", {
          get: d,
          configurable: !0
        });
      }
    }
    var Us = function(n, c, d, m, x, I, F) {
      var C = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: n,
        key: c,
        ref: d,
        props: F,
        // Record the component responsible for creating this element.
        _owner: I
      };
      return C._store = {}, Object.defineProperty(C._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(C, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: m
      }), Object.defineProperty(C, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: x
      }), Object.freeze && (Object.freeze(C.props), Object.freeze(C)), C;
    };
    function Ks(n, c, d, m, x) {
      {
        var I, F = {}, C = null, J = null;
        d !== void 0 && (Rr(d), C = "" + d), js(c) && (Rr(c.key), C = "" + c.key), Ms(c) && (J = c.ref, ks(c, x));
        for (I in c)
          lt.call(c, I) && !Is.hasOwnProperty(I) && (F[I] = c[I]);
        if (n && n.defaultProps) {
          var U = n.defaultProps;
          for (I in U)
            F[I] === void 0 && (F[I] = U[I]);
        }
        if (C || J) {
          var L = typeof n == "function" ? n.displayName || n.name || "Unknown" : n;
          C && qs(F, L), J && Qs(F, L);
        }
        return Us(n, C, J, x, m, ht.current, F);
      }
    }
    var Nt = D.ReactCurrentOwner, Cr = D.ReactDebugCurrentFrame;
    function Be(n) {
      if (n) {
        var c = n._owner, d = St(n.type, n._source, c ? c.type : null);
        Cr.setExtraStackFrame(d);
      } else
        Cr.setExtraStackFrame(null);
    }
    var Lt;
    Lt = !1;
    function $t(n) {
      return typeof n == "object" && n !== null && n.$$typeof === e;
    }
    function Pr() {
      {
        if (Nt.current) {
          var n = G(Nt.current.type);
          if (n)
            return `

Check the render method of \`` + n + "`.";
        }
        return "";
      }
    }
    function Ns(n) {
      return "";
    }
    var _r = {};
    function Ls(n) {
      {
        var c = Pr();
        if (!c) {
          var d = typeof n == "string" ? n : n.displayName || n.name;
          d && (c = `

Check the top-level render call using <` + d + ">.");
        }
        return c;
      }
    }
    function Tr(n, c) {
      {
        if (!n._store || n._store.validated || n.key != null)
          return;
        n._store.validated = !0;
        var d = Ls(c);
        if (_r[d])
          return;
        _r[d] = !0;
        var m = "";
        n && n._owner && n._owner !== Nt.current && (m = " It was passed a child from " + G(n._owner.type) + "."), Be(n), _('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', d, m), Be(null);
      }
    }
    function Fr(n, c) {
      {
        if (typeof n != "object")
          return;
        if (Ut(n))
          for (var d = 0; d < n.length; d++) {
            var m = n[d];
            $t(m) && Tr(m, c);
          }
        else if ($t(n))
          n._store && (n._store.validated = !0);
        else if (n) {
          var x = O(n);
          if (typeof x == "function" && x !== n.entries)
            for (var I = x.call(n), F; !(F = I.next()).done; )
              $t(F.value) && Tr(F.value, c);
        }
      }
    }
    function $s(n) {
      {
        var c = n.type;
        if (c == null || typeof c == "string")
          return;
        var d;
        if (typeof c == "function")
          d = c.propTypes;
        else if (typeof c == "object" && (c.$$typeof === h || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        c.$$typeof === p))
          d = c.propTypes;
        else
          return;
        if (d) {
          var m = G(c);
          Fs(d, n.props, "prop", m, n);
        } else if (c.PropTypes !== void 0 && !Lt) {
          Lt = !0;
          var x = G(c);
          _("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", x || "Unknown");
        }
        typeof c.getDefaultProps == "function" && !c.getDefaultProps.isReactClassApproved && _("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Hs(n) {
      {
        for (var c = Object.keys(n.props), d = 0; d < c.length; d++) {
          var m = c[d];
          if (m !== "children" && m !== "key") {
            Be(n), _("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", m), Be(null);
            break;
          }
        }
        n.ref !== null && (Be(n), _("Invalid attribute `ref` supplied to `React.Fragment`."), Be(null));
      }
    }
    var Dr = {};
    function xr(n, c, d, m, x, I) {
      {
        var F = N(n);
        if (!F) {
          var C = "";
          (n === void 0 || typeof n == "object" && n !== null && Object.keys(n).length === 0) && (C += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var J = Ns();
          J ? C += J : C += Pr();
          var U;
          n === null ? U = "null" : Ut(n) ? U = "array" : n !== void 0 && n.$$typeof === e ? (U = "<" + (G(n.type) || "Unknown") + " />", C = " Did you accidentally export a JSX literal instead of a component?") : U = typeof n, _("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", U, C);
        }
        var L = Ks(n, c, d, x, I);
        if (L == null)
          return L;
        if (F) {
          var ne = c.children;
          if (ne !== void 0)
            if (m)
              if (Ut(ne)) {
                for (var Ye = 0; Ye < ne.length; Ye++)
                  Fr(ne[Ye], n);
                Object.freeze && Object.freeze(ne);
              } else
                _("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fr(ne, n);
        }
        if (lt.call(c, "key")) {
          var Ae = G(n), re = Object.keys(c).filter(function(Gs) {
            return Gs !== "key";
          }), Ht = re.length > 0 ? "{key: someKey, " + re.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Dr[Ae + Ht]) {
            var zs = re.length > 0 ? "{" + re.join(": ..., ") + ": ...}" : "{}";
            _(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Ht, Ae, zs, Ae), Dr[Ae + Ht] = !0;
          }
        }
        return n === s ? Hs(L) : $s(L), L;
      }
    }
    function Vs(n, c, d) {
      return xr(n, c, d, !0);
    }
    function Ws(n, c, d) {
      return xr(n, c, d, !1);
    }
    var Bs = Ws, Ys = Vs;
    dt.Fragment = s, dt.jsx = Bs, dt.jsxs = Ys;
  }()), dt;
}
var Nr;
function si() {
  return Nr || (Nr = 1, process.env.NODE_ENV === "production" ? _t.exports = ti() : _t.exports = ri()), _t.exports;
}
var ls = si(), ut = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, ii = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (t, e) => setTimeout(t, e),
  clearTimeout: (t) => clearTimeout(t),
  setInterval: (t, e) => setInterval(t, e),
  clearInterval: (t) => clearInterval(t)
}, he, Me, Xr, ni = (Xr = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    y(this, he, ii);
    y(this, Me, !1);
  }
  setTimeoutProvider(t) {
    process.env.NODE_ENV !== "production" && i(this, Me) && t !== i(this, he) && console.error(
      "[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.",
      { previous: i(this, he), provider: t }
    ), f(this, he, t), process.env.NODE_ENV !== "production" && f(this, Me, !1);
  }
  setTimeout(t, e) {
    return process.env.NODE_ENV !== "production" && f(this, Me, !0), i(this, he).setTimeout(t, e);
  }
  clearTimeout(t) {
    i(this, he).clearTimeout(t);
  }
  setInterval(t, e) {
    return process.env.NODE_ENV !== "production" && f(this, Me, !0), i(this, he).setInterval(t, e);
  }
  clearInterval(t) {
    i(this, he).clearInterval(t);
  }
}, he = new WeakMap(), Me = new WeakMap(), Xr), Ie = new ni();
function ai(t) {
  setTimeout(t, 0);
}
var Ve = typeof window == "undefined" || "Deno" in globalThis;
function ee() {
}
function oi(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Wt(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function hs(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function De(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function oe(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function Lr(t, e) {
  const {
    type: r = "all",
    exact: s,
    fetchStatus: a,
    predicate: o,
    queryKey: u,
    stale: l
  } = t;
  if (u) {
    if (s) {
      if (e.queryHash !== or(u, e.options))
        return !1;
    } else if (!pt(e.queryKey, u))
      return !1;
  }
  if (r !== "all") {
    const h = e.isActive();
    if (r === "active" && !h || r === "inactive" && h)
      return !1;
  }
  return !(typeof l == "boolean" && e.isStale() !== l || a && a !== e.state.fetchStatus || o && !o(e));
}
function $r(t, e) {
  const { exact: r, status: s, predicate: a, mutationKey: o } = t;
  if (o) {
    if (!e.options.mutationKey)
      return !1;
    if (r) {
      if (We(e.options.mutationKey) !== We(o))
        return !1;
    } else if (!pt(e.options.mutationKey, o))
      return !1;
  }
  return !(s && e.state.status !== s || a && !a(e));
}
function or(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || We)(t);
}
function We(t) {
  return JSON.stringify(
    t,
    (e, r) => Yt(r) ? Object.keys(r).sort().reduce((s, a) => (s[a] = r[a], s), {}) : r
  );
}
function pt(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every((r) => pt(t[r], e[r])) : !1;
}
var ui = Object.prototype.hasOwnProperty;
function Bt(t, e) {
  if (t === e)
    return t;
  const r = Hr(t) && Hr(e);
  if (!r && !(Yt(t) && Yt(e))) return e;
  const a = (r ? t : Object.keys(t)).length, o = r ? e : Object.keys(e), u = o.length, l = r ? new Array(u) : {};
  let h = 0;
  for (let E = 0; E < u; E++) {
    const g = r ? E : o[E], p = t[g], S = e[g];
    if (p === S) {
      l[g] = p, (r ? E < a : ui.call(t, g)) && h++;
      continue;
    }
    if (p === null || S === null || typeof p != "object" || typeof S != "object") {
      l[g] = S;
      continue;
    }
    const R = Bt(p, S);
    l[g] = R, R === p && h++;
  }
  return a === u && h === a ? t : l;
}
function Dt(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const r in t)
    if (t[r] !== e[r])
      return !1;
  return !0;
}
function Hr(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Yt(t) {
  if (!Vr(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const r = e.prototype;
  return !(!Vr(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Vr(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function ci(t) {
  return new Promise((e) => {
    Ie.setTimeout(e, t);
  });
}
function zt(t, e, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(t, e);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Bt(t, e);
      } catch (s) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${s}`
        ), s;
      }
    return Bt(t, e);
  }
  return e;
}
function li(t, e, r = 0) {
  const s = [...t, e];
  return r && s.length > r ? s.slice(1) : s;
}
function hi(t, e, r = 0) {
  const s = [e, ...t];
  return r && s.length > r ? s.slice(0, -1) : s;
}
var xt = Symbol();
function fs(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === xt && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === xt ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
function ds(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
var je, Re, Ge, Zr, fi = (Zr = class extends ut {
  constructor() {
    super();
    y(this, je);
    y(this, Re);
    y(this, Ge);
    f(this, Ge, (e) => {
      if (!Ve && window.addEventListener) {
        const r = () => e();
        return window.addEventListener("visibilitychange", r, !1), () => {
          window.removeEventListener("visibilitychange", r);
        };
      }
    });
  }
  onSubscribe() {
    i(this, Re) || this.setEventListener(i(this, Ge));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = i(this, Re)) == null || e.call(this), f(this, Re, void 0));
  }
  setEventListener(e) {
    var r;
    f(this, Ge, e), (r = i(this, Re)) == null || r.call(this), f(this, Re, e((s) => {
      typeof s == "boolean" ? this.setFocused(s) : this.onFocus();
    }));
  }
  setFocused(e) {
    i(this, je) !== e && (f(this, je, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((r) => {
      r(e);
    });
  }
  isFocused() {
    var e;
    return typeof i(this, je) == "boolean" ? i(this, je) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, je = new WeakMap(), Re = new WeakMap(), Ge = new WeakMap(), Zr), ur = new fi();
function Gt() {
  let t, e;
  const r = new Promise((a, o) => {
    t = a, e = o;
  });
  r.status = "pending", r.catch(() => {
  });
  function s(a) {
    Object.assign(r, a), delete r.resolve, delete r.reject;
  }
  return r.resolve = (a) => {
    s({
      status: "fulfilled",
      value: a
    }), t(a);
  }, r.reject = (a) => {
    s({
      status: "rejected",
      reason: a
    }), e(a);
  }, r;
}
var di = ai;
function yi() {
  let t = [], e = 0, r = (l) => {
    l();
  }, s = (l) => {
    l();
  }, a = di;
  const o = (l) => {
    e ? t.push(l) : a(() => {
      r(l);
    });
  }, u = () => {
    const l = t;
    t = [], l.length && a(() => {
      s(() => {
        l.forEach((h) => {
          r(h);
        });
      });
    });
  };
  return {
    batch: (l) => {
      let h;
      e++;
      try {
        h = l();
      } finally {
        e--, e || u();
      }
      return h;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (l) => (...h) => {
      o(() => {
        l(...h);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (l) => {
      r = l;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (l) => {
      s = l;
    },
    setScheduler: (l) => {
      a = l;
    }
  };
}
var V = yi(), Je, Se, Xe, es, pi = (es = class extends ut {
  constructor() {
    super();
    y(this, Je, !0);
    y(this, Se);
    y(this, Xe);
    f(this, Xe, (e) => {
      if (!Ve && window.addEventListener) {
        const r = () => e(!0), s = () => e(!1);
        return window.addEventListener("online", r, !1), window.addEventListener("offline", s, !1), () => {
          window.removeEventListener("online", r), window.removeEventListener("offline", s);
        };
      }
    });
  }
  onSubscribe() {
    i(this, Se) || this.setEventListener(i(this, Xe));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = i(this, Se)) == null || e.call(this), f(this, Se, void 0));
  }
  setEventListener(e) {
    var r;
    f(this, Xe, e), (r = i(this, Se)) == null || r.call(this), f(this, Se, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    i(this, Je) !== e && (f(this, Je, e), this.listeners.forEach((s) => {
      s(e);
    }));
  }
  isOnline() {
    return i(this, Je);
  }
}, Je = new WeakMap(), Se = new WeakMap(), Xe = new WeakMap(), es), At = new pi();
function vi(t) {
  return Math.min(1e3 * kr(2, t), 3e4);
}
function ys(t) {
  return (t != null ? t : "online") === "online" ? At.isOnline() : !0;
}
var Jt = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function ps(t) {
  let e = !1, r = 0, s;
  const a = Gt(), o = () => a.status !== "pending", u = (P) => {
    var O;
    if (!o()) {
      const D = new Jt(P);
      S(D), (O = t.onCancel) == null || O.call(t, D);
    }
  }, l = () => {
    e = !0;
  }, h = () => {
    e = !1;
  }, E = () => ur.isFocused() && (t.networkMode === "always" || At.isOnline()) && t.canRun(), g = () => ys(t.networkMode) && t.canRun(), p = (P) => {
    o() || (s == null || s(), a.resolve(P));
  }, S = (P) => {
    o() || (s == null || s(), a.reject(P));
  }, R = () => new Promise((P) => {
    var O;
    s = (D) => {
      (o() || E()) && P(D);
    }, (O = t.onPause) == null || O.call(t);
  }).then(() => {
    var P;
    s = void 0, o() || (P = t.onContinue) == null || P.call(t);
  }), Q = () => {
    if (o())
      return;
    let P;
    const O = r === 0 ? t.initialPromise : void 0;
    try {
      P = O != null ? O : t.fn();
    } catch (D) {
      P = Promise.reject(D);
    }
    Promise.resolve(P).then(p).catch((D) => {
      var $, te, K;
      if (o())
        return;
      const _ = ($ = t.retry) != null ? $ : Ve ? 0 : 3, W = (te = t.retryDelay) != null ? te : vi, v = typeof W == "function" ? W(r, D) : W, k = _ === !0 || typeof _ == "number" && r < _ || typeof _ == "function" && _(r, D);
      if (e || !k) {
        S(D);
        return;
      }
      r++, (K = t.onFail) == null || K.call(t, r, D), ci(v).then(() => E() ? void 0 : R()).then(() => {
        e ? S(D) : Q();
      });
    });
  };
  return {
    promise: a,
    status: () => a.status,
    cancel: u,
    continue: () => (s == null || s(), a),
    cancelRetry: l,
    continueRetry: h,
    canStart: g,
    start: () => (g() ? Q() : R().then(Q), a)
  };
}
var ke, ts, vs = (ts = class {
  constructor() {
    y(this, ke);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Wt(this.gcTime) && f(this, ke, Ie.setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t != null ? t : Ve ? 1 / 0 : 5 * 60 * 1e3
    );
  }
  clearGcTimeout() {
    i(this, ke) && (Ie.clearTimeout(i(this, ke)), f(this, ke, void 0));
  }
}, ke = new WeakMap(), ts), qe, Ze, ae, Qe, B, vt, Ue, ue, pe, rs, mi = (rs = class extends vs {
  constructor(e) {
    var r;
    super();
    y(this, ue);
    y(this, qe);
    y(this, Ze);
    y(this, ae);
    y(this, Qe);
    y(this, B);
    y(this, vt);
    y(this, Ue);
    f(this, Ue, !1), f(this, vt, e.defaultOptions), this.setOptions(e.options), this.observers = [], f(this, Qe, e.client), f(this, ae, i(this, Qe).getQueryCache()), this.queryKey = e.queryKey, this.queryHash = e.queryHash, f(this, qe, Wr(this.options)), this.state = (r = e.state) != null ? r : i(this, qe), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = i(this, B)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    if (this.options = b(b({}, i(this, vt)), e), this.updateGcTime(this.options.gcTime), this.state && this.state.data === void 0) {
      const r = Wr(this.options);
      r.data !== void 0 && (this.setData(r.data, {
        updatedAt: r.dataUpdatedAt,
        manual: !0
      }), f(this, qe, r));
    }
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && i(this, ae).remove(this);
  }
  setData(e, r) {
    const s = zt(this.state.data, e, this.options);
    return w(this, ue, pe).call(this, {
      data: s,
      type: "success",
      dataUpdatedAt: r == null ? void 0 : r.updatedAt,
      manual: r == null ? void 0 : r.manual
    }), s;
  }
  setState(e, r) {
    w(this, ue, pe).call(this, { type: "setState", state: e, setStateOptions: r });
  }
  cancel(e) {
    var s, a;
    const r = (s = i(this, B)) == null ? void 0 : s.promise;
    return (a = i(this, B)) == null || a.cancel(e), r ? r.then(ee).catch(ee) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(i(this, qe));
  }
  isActive() {
    return this.observers.some(
      (e) => oe(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === xt || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => De(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !hs(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var r;
    const e = this.observers.find((s) => s.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (r = i(this, B)) == null || r.continue();
  }
  onOnline() {
    var r;
    const e = this.observers.find((s) => s.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (r = i(this, B)) == null || r.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), i(this, ae).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((r) => r !== e), this.observers.length || (i(this, B) && (i(this, Ue) ? i(this, B).cancel({ revert: !0 }) : i(this, B).cancelRetry()), this.scheduleGc()), i(this, ae).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || w(this, ue, pe).call(this, { type: "invalidate" });
  }
  fetch(e, r) {
    return H(this, null, function* () {
      var h, E, g, p, S, R, Q, P, O, D, _, W;
      if (this.state.fetchStatus !== "idle" && // If the promise in the retyer is already rejected, we have to definitely
      // re-start the fetch; there is a chance that the query is still in a
      // pending state when that happens
      ((h = i(this, B)) == null ? void 0 : h.status()) !== "rejected") {
        if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
          this.cancel({ silent: !0 });
        else if (i(this, B))
          return i(this, B).continueRetry(), i(this, B).promise;
      }
      if (e && this.setOptions(e), !this.options.queryFn) {
        const v = this.observers.find((k) => k.options.queryFn);
        v && this.setOptions(v.options);
      }
      process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
        "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
      ));
      const s = new AbortController(), a = (v) => {
        Object.defineProperty(v, "signal", {
          enumerable: !0,
          get: () => (f(this, Ue, !0), s.signal)
        });
      }, o = () => {
        const v = fs(this.options, r), $ = (() => {
          const te = {
            client: i(this, Qe),
            queryKey: this.queryKey,
            meta: this.meta
          };
          return a(te), te;
        })();
        return f(this, Ue, !1), this.options.persister ? this.options.persister(
          v,
          $,
          this
        ) : v($);
      }, l = (() => {
        const v = {
          fetchOptions: r,
          options: this.options,
          queryKey: this.queryKey,
          client: i(this, Qe),
          state: this.state,
          fetchFn: o
        };
        return a(v), v;
      })();
      (E = this.options.behavior) == null || E.onFetch(l, this), f(this, Ze, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((g = l.fetchOptions) == null ? void 0 : g.meta)) && w(this, ue, pe).call(this, { type: "fetch", meta: (p = l.fetchOptions) == null ? void 0 : p.meta }), f(this, B, ps({
        initialPromise: r == null ? void 0 : r.initialPromise,
        fn: l.fetchFn,
        onCancel: (v) => {
          v instanceof Jt && v.revert && this.setState(j(b({}, i(this, Ze)), {
            fetchStatus: "idle"
          })), s.abort();
        },
        onFail: (v, k) => {
          w(this, ue, pe).call(this, { type: "failed", failureCount: v, error: k });
        },
        onPause: () => {
          w(this, ue, pe).call(this, { type: "pause" });
        },
        onContinue: () => {
          w(this, ue, pe).call(this, { type: "continue" });
        },
        retry: l.options.retry,
        retryDelay: l.options.retryDelay,
        networkMode: l.options.networkMode,
        canRun: () => !0
      }));
      try {
        const v = yield i(this, B).start();
        if (v === void 0)
          throw process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), new Error(`${this.queryHash} data is undefined`);
        return this.setData(v), (R = (S = i(this, ae).config).onSuccess) == null || R.call(S, v, this), (P = (Q = i(this, ae).config).onSettled) == null || P.call(
          Q,
          v,
          this.state.error,
          this
        ), v;
      } catch (v) {
        if (v instanceof Jt) {
          if (v.silent)
            return i(this, B).promise;
          if (v.revert) {
            if (this.state.data === void 0)
              throw v;
            return this.state.data;
          }
        }
        throw w(this, ue, pe).call(this, {
          type: "error",
          error: v
        }), (D = (O = i(this, ae).config).onError) == null || D.call(
          O,
          v,
          this
        ), (W = (_ = i(this, ae).config).onSettled) == null || W.call(
          _,
          this.state.data,
          v,
          this
        ), v;
      } finally {
        this.scheduleGc();
      }
    });
  }
}, qe = new WeakMap(), Ze = new WeakMap(), ae = new WeakMap(), Qe = new WeakMap(), B = new WeakMap(), vt = new WeakMap(), Ue = new WeakMap(), ue = new WeakSet(), pe = function(e) {
  const r = (s) => {
    var a, o;
    switch (e.type) {
      case "failed":
        return j(b({}, s), {
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        });
      case "pause":
        return j(b({}, s), {
          fetchStatus: "paused"
        });
      case "continue":
        return j(b({}, s), {
          fetchStatus: "fetching"
        });
      case "fetch":
        return j(b(b({}, s), ms(s.data, this.options)), {
          fetchMeta: (a = e.meta) != null ? a : null
        });
      case "success":
        const u = b(j(b({}, s), {
          data: e.data,
          dataUpdateCount: s.dataUpdateCount + 1,
          dataUpdatedAt: (o = e.dataUpdatedAt) != null ? o : Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success"
        }), !e.manual && {
          fetchStatus: "idle",
          fetchFailureCount: 0,
          fetchFailureReason: null
        });
        return f(this, Ze, e.manual ? u : void 0), u;
      case "error":
        const l = e.error;
        return j(b({}, s), {
          error: l,
          errorUpdateCount: s.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: s.fetchFailureCount + 1,
          fetchFailureReason: l,
          fetchStatus: "idle",
          status: "error"
        });
      case "invalidate":
        return j(b({}, s), {
          isInvalidated: !0
        });
      case "setState":
        return b(b({}, s), e.state);
    }
  };
  this.state = r(this.state), V.batch(() => {
    this.observers.forEach((s) => {
      s.onQueryUpdate();
    }), i(this, ae).notify({ query: this, type: "updated", action: e });
  });
}, rs);
function ms(t, e) {
  return b({
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: ys(e.networkMode) ? "fetching" : "paused"
  }, t === void 0 && {
    error: null,
    status: "pending"
  });
}
function Wr(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, r = e !== void 0, s = r ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? s != null ? s : Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var se, T, mt, X, Ke, et, ve, Oe, gt, tt, rt, Ne, Le, Ce, st, A, yt, Xt, Zt, er, tr, rr, sr, ir, gs, ss, gi = (ss = class extends ut {
  constructor(e, r) {
    super();
    y(this, A);
    y(this, se);
    y(this, T);
    y(this, mt);
    y(this, X);
    y(this, Ke);
    y(this, et);
    y(this, ve);
    y(this, Oe);
    y(this, gt);
    y(this, tt);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    y(this, rt);
    y(this, Ne);
    y(this, Le);
    y(this, Ce);
    y(this, st, /* @__PURE__ */ new Set());
    this.options = r, f(this, se, e), f(this, Oe, null), f(this, ve, Gt()), this.bindMethods(), this.setOptions(r);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (i(this, T).addObserver(this), Br(i(this, T), this.options) ? w(this, A, yt).call(this) : this.updateResult(), w(this, A, tr).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return nr(
      i(this, T),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return nr(
      i(this, T),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), w(this, A, rr).call(this), w(this, A, sr).call(this), i(this, T).removeObserver(this);
  }
  setOptions(e) {
    const r = this.options, s = i(this, T);
    if (this.options = i(this, se).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof oe(this.options.enabled, i(this, T)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    w(this, A, ir).call(this), i(this, T).setOptions(this.options), r._defaulted && !Dt(this.options, r) && i(this, se).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: i(this, T),
      observer: this
    });
    const a = this.hasListeners();
    a && Yr(
      i(this, T),
      s,
      this.options,
      r
    ) && w(this, A, yt).call(this), this.updateResult(), a && (i(this, T) !== s || oe(this.options.enabled, i(this, T)) !== oe(r.enabled, i(this, T)) || De(this.options.staleTime, i(this, T)) !== De(r.staleTime, i(this, T))) && w(this, A, Xt).call(this);
    const o = w(this, A, Zt).call(this);
    a && (i(this, T) !== s || oe(this.options.enabled, i(this, T)) !== oe(r.enabled, i(this, T)) || o !== i(this, Ce)) && w(this, A, er).call(this, o);
  }
  getOptimisticResult(e) {
    const r = i(this, se).getQueryCache().build(i(this, se), e), s = this.createResult(r, e);
    return Ei(this, s) && (f(this, X, s), f(this, et, this.options), f(this, Ke, i(this, T).state)), s;
  }
  getCurrentResult() {
    return i(this, X);
  }
  trackResult(e, r) {
    return new Proxy(e, {
      get: (s, a) => (this.trackProp(a), r == null || r(a), a === "promise" && !this.options.experimental_prefetchInRender && i(this, ve).status === "pending" && i(this, ve).reject(
        new Error(
          "experimental_prefetchInRender feature flag is not enabled"
        )
      ), Reflect.get(s, a))
    });
  }
  trackProp(e) {
    i(this, st).add(e);
  }
  getCurrentQuery() {
    return i(this, T);
  }
  refetch(r = {}) {
    var e = qr(r, []);
    return this.fetch(b({}, e));
  }
  fetchOptimistic(e) {
    const r = i(this, se).defaultQueryOptions(e), s = i(this, se).getQueryCache().build(i(this, se), r);
    return s.fetch().then(() => this.createResult(s, r));
  }
  fetch(e) {
    var r;
    return w(this, A, yt).call(this, j(b({}, e), {
      cancelRefetch: (r = e.cancelRefetch) != null ? r : !0
    })).then(() => (this.updateResult(), i(this, X)));
  }
  createResult(e, r) {
    var le;
    const s = i(this, T), a = this.options, o = i(this, X), u = i(this, Ke), l = i(this, et), E = e !== s ? e.state : i(this, mt), { state: g } = e;
    let p = b({}, g), S = !1, R;
    if (r._optimisticResults) {
      const N = this.hasListeners(), M = !N && Br(e, r), Y = N && Yr(e, s, r, a);
      (M || Y) && (p = b(b({}, p), ms(g.data, e.options))), r._optimisticResults === "isRestoring" && (p.fetchStatus = "idle");
    }
    let { error: Q, errorUpdatedAt: P, status: O } = p;
    R = p.data;
    let D = !1;
    if (r.placeholderData !== void 0 && R === void 0 && O === "pending") {
      let N;
      o != null && o.isPlaceholderData && r.placeholderData === (l == null ? void 0 : l.placeholderData) ? (N = o.data, D = !0) : N = typeof r.placeholderData == "function" ? r.placeholderData(
        (le = i(this, rt)) == null ? void 0 : le.state.data,
        i(this, rt)
      ) : r.placeholderData, N !== void 0 && (O = "success", R = zt(
        o == null ? void 0 : o.data,
        N,
        r
      ), S = !0);
    }
    if (r.select && R !== void 0 && !D)
      if (o && R === (u == null ? void 0 : u.data) && r.select === i(this, gt))
        R = i(this, tt);
      else
        try {
          f(this, gt, r.select), R = r.select(R), R = zt(o == null ? void 0 : o.data, R, r), f(this, tt, R), f(this, Oe, null);
        } catch (N) {
          f(this, Oe, N);
        }
    i(this, Oe) && (Q = i(this, Oe), R = i(this, tt), P = Date.now(), O = "error");
    const _ = p.fetchStatus === "fetching", W = O === "pending", v = O === "error", k = W && _, $ = R !== void 0, K = {
      status: O,
      fetchStatus: p.fetchStatus,
      isPending: W,
      isSuccess: O === "success",
      isError: v,
      isInitialLoading: k,
      isLoading: k,
      data: R,
      dataUpdatedAt: p.dataUpdatedAt,
      error: Q,
      errorUpdatedAt: P,
      failureCount: p.fetchFailureCount,
      failureReason: p.fetchFailureReason,
      errorUpdateCount: p.errorUpdateCount,
      isFetched: p.dataUpdateCount > 0 || p.errorUpdateCount > 0,
      isFetchedAfterMount: p.dataUpdateCount > E.dataUpdateCount || p.errorUpdateCount > E.errorUpdateCount,
      isFetching: _,
      isRefetching: _ && !W,
      isLoadingError: v && !$,
      isPaused: p.fetchStatus === "paused",
      isPlaceholderData: S,
      isRefetchError: v && $,
      isStale: cr(e, r),
      refetch: this.refetch,
      promise: i(this, ve),
      isEnabled: oe(r.enabled, e) !== !1
    };
    if (this.options.experimental_prefetchInRender) {
      const N = (G) => {
        K.status === "error" ? G.reject(K.error) : K.data !== void 0 && G.resolve(K.data);
      }, M = () => {
        const G = f(this, ve, K.promise = Gt());
        N(G);
      }, Y = i(this, ve);
      switch (Y.status) {
        case "pending":
          e.queryHash === s.queryHash && N(Y);
          break;
        case "fulfilled":
          (K.status === "error" || K.data !== Y.value) && M();
          break;
        case "rejected":
          (K.status !== "error" || K.error !== Y.reason) && M();
          break;
      }
    }
    return K;
  }
  updateResult() {
    const e = i(this, X), r = this.createResult(i(this, T), this.options);
    if (f(this, Ke, i(this, T).state), f(this, et, this.options), i(this, Ke).data !== void 0 && f(this, rt, i(this, T)), Dt(r, e))
      return;
    f(this, X, r);
    const s = () => {
      if (!e)
        return !0;
      const { notifyOnChangeProps: a } = this.options, o = typeof a == "function" ? a() : a;
      if (o === "all" || !o && !i(this, st).size)
        return !0;
      const u = new Set(
        o != null ? o : i(this, st)
      );
      return this.options.throwOnError && u.add("error"), Object.keys(i(this, X)).some((l) => {
        const h = l;
        return i(this, X)[h] !== e[h] && u.has(h);
      });
    };
    w(this, A, gs).call(this, { listeners: s() });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && w(this, A, tr).call(this);
  }
}, se = new WeakMap(), T = new WeakMap(), mt = new WeakMap(), X = new WeakMap(), Ke = new WeakMap(), et = new WeakMap(), ve = new WeakMap(), Oe = new WeakMap(), gt = new WeakMap(), tt = new WeakMap(), rt = new WeakMap(), Ne = new WeakMap(), Le = new WeakMap(), Ce = new WeakMap(), st = new WeakMap(), A = new WeakSet(), yt = function(e) {
  w(this, A, ir).call(this);
  let r = i(this, T).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (r = r.catch(ee)), r;
}, Xt = function() {
  w(this, A, rr).call(this);
  const e = De(
    this.options.staleTime,
    i(this, T)
  );
  if (Ve || i(this, X).isStale || !Wt(e))
    return;
  const s = hs(i(this, X).dataUpdatedAt, e) + 1;
  f(this, Ne, Ie.setTimeout(() => {
    i(this, X).isStale || this.updateResult();
  }, s));
}, Zt = function() {
  var e;
  return (e = typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(i(this, T)) : this.options.refetchInterval) != null ? e : !1;
}, er = function(e) {
  w(this, A, sr).call(this), f(this, Ce, e), !(Ve || oe(this.options.enabled, i(this, T)) === !1 || !Wt(i(this, Ce)) || i(this, Ce) === 0) && f(this, Le, Ie.setInterval(() => {
    (this.options.refetchIntervalInBackground || ur.isFocused()) && w(this, A, yt).call(this);
  }, i(this, Ce)));
}, tr = function() {
  w(this, A, Xt).call(this), w(this, A, er).call(this, w(this, A, Zt).call(this));
}, rr = function() {
  i(this, Ne) && (Ie.clearTimeout(i(this, Ne)), f(this, Ne, void 0));
}, sr = function() {
  i(this, Le) && (Ie.clearInterval(i(this, Le)), f(this, Le, void 0));
}, ir = function() {
  const e = i(this, se).getQueryCache().build(i(this, se), this.options);
  if (e === i(this, T))
    return;
  const r = i(this, T);
  f(this, T, e), f(this, mt, e.state), this.hasListeners() && (r == null || r.removeObserver(this), e.addObserver(this));
}, gs = function(e) {
  V.batch(() => {
    e.listeners && this.listeners.forEach((r) => {
      r(i(this, X));
    }), i(this, se).getQueryCache().notify({
      query: i(this, T),
      type: "observerResultsUpdated"
    });
  });
}, ss);
function bi(t, e) {
  return oe(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function Br(t, e) {
  return bi(t, e) || t.state.data !== void 0 && nr(t, e, e.refetchOnMount);
}
function nr(t, e, r) {
  if (oe(e.enabled, t) !== !1 && De(e.staleTime, t) !== "static") {
    const s = typeof r == "function" ? r(t) : r;
    return s === "always" || s !== !1 && cr(t, e);
  }
  return !1;
}
function Yr(t, e, r, s) {
  return (t !== e || oe(s.enabled, t) === !1) && (!r.suspense || t.state.status !== "error") && cr(t, r);
}
function cr(t, e) {
  return oe(e.enabled, t) !== !1 && t.isStaleByTime(De(e.staleTime, t));
}
function Ei(t, e) {
  return !Dt(t.getCurrentResult(), e);
}
function zr(t) {
  return {
    onFetch: (e, r) => {
      var g, p, S, R, Q;
      const s = e.options, a = (S = (p = (g = e.fetchOptions) == null ? void 0 : g.meta) == null ? void 0 : p.fetchMore) == null ? void 0 : S.direction, o = ((R = e.state.data) == null ? void 0 : R.pages) || [], u = ((Q = e.state.data) == null ? void 0 : Q.pageParams) || [];
      let l = { pages: [], pageParams: [] }, h = 0;
      const E = () => H(this, null, function* () {
        var W;
        let P = !1;
        const O = (v) => {
          Object.defineProperty(v, "signal", {
            enumerable: !0,
            get: () => (e.signal.aborted ? P = !0 : e.signal.addEventListener("abort", () => {
              P = !0;
            }), e.signal)
          });
        }, D = fs(e.options, e.fetchOptions), _ = (v, k, $) => H(this, null, function* () {
          if (P)
            return Promise.reject();
          if (k == null && v.pages.length)
            return Promise.resolve(v);
          const K = (() => {
            const Y = {
              client: e.client,
              queryKey: e.queryKey,
              pageParam: k,
              direction: $ ? "backward" : "forward",
              meta: e.options.meta
            };
            return O(Y), Y;
          })(), le = yield D(K), { maxPages: N } = e.options, M = $ ? hi : li;
          return {
            pages: M(v.pages, le, N),
            pageParams: M(v.pageParams, k, N)
          };
        });
        if (a && o.length) {
          const v = a === "backward", k = v ? wi : Gr, $ = {
            pages: o,
            pageParams: u
          }, te = k(s, $);
          l = yield _($, te, v);
        } else {
          const v = t != null ? t : o.length;
          do {
            const k = h === 0 ? (W = u[0]) != null ? W : s.initialPageParam : Gr(s, l);
            if (h > 0 && k == null)
              break;
            l = yield _(l, k), h++;
          } while (h < v);
        }
        return l;
      });
      e.options.persister ? e.fetchFn = () => {
        var P, O;
        return (O = (P = e.options).persister) == null ? void 0 : O.call(
          P,
          E,
          {
            client: e.client,
            queryKey: e.queryKey,
            meta: e.options.meta,
            signal: e.signal
          },
          r
        );
      } : e.fetchFn = E;
    }
  };
}
function Gr(t, { pages: e, pageParams: r }) {
  const s = e.length - 1;
  return e.length > 0 ? t.getNextPageParam(
    e[s],
    e,
    r[s],
    r
  ) : void 0;
}
function wi(t, { pages: e, pageParams: r }) {
  var s;
  return e.length > 0 ? (s = t.getPreviousPageParam) == null ? void 0 : s.call(t, e[0], e, r[0], r) : void 0;
}
var bt, fe, Z, $e, de, we, is, Ri = (is = class extends vs {
  constructor(e) {
    super();
    y(this, de);
    y(this, bt);
    y(this, fe);
    y(this, Z);
    y(this, $e);
    f(this, bt, e.client), this.mutationId = e.mutationId, f(this, Z, e.mutationCache), f(this, fe, []), this.state = e.state || bs(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    i(this, fe).includes(e) || (i(this, fe).push(e), this.clearGcTimeout(), i(this, Z).notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    f(this, fe, i(this, fe).filter((r) => r !== e)), this.scheduleGc(), i(this, Z).notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    i(this, fe).length || (this.state.status === "pending" ? this.scheduleGc() : i(this, Z).remove(this));
  }
  continue() {
    var e, r;
    return (r = (e = i(this, $e)) == null ? void 0 : e.continue()) != null ? r : (
      // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
      this.execute(this.state.variables)
    );
  }
  execute(e) {
    return H(this, null, function* () {
      var u, l, h, E, g, p, S, R, Q, P, O, D, _, W, v, k, $, te, K, le, N;
      const r = () => {
        w(this, de, we).call(this, { type: "continue" });
      }, s = {
        client: i(this, bt),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      f(this, $e, ps({
        fn: () => this.options.mutationFn ? this.options.mutationFn(e, s) : Promise.reject(new Error("No mutationFn found")),
        onFail: (M, Y) => {
          w(this, de, we).call(this, { type: "failed", failureCount: M, error: Y });
        },
        onPause: () => {
          w(this, de, we).call(this, { type: "pause" });
        },
        onContinue: r,
        retry: (u = this.options.retry) != null ? u : 0,
        retryDelay: this.options.retryDelay,
        networkMode: this.options.networkMode,
        canRun: () => i(this, Z).canRun(this)
      }));
      const a = this.state.status === "pending", o = !i(this, $e).canStart();
      try {
        if (a)
          r();
        else {
          w(this, de, we).call(this, { type: "pending", variables: e, isPaused: o }), yield (h = (l = i(this, Z).config).onMutate) == null ? void 0 : h.call(
            l,
            e,
            this,
            s
          );
          const Y = yield (g = (E = this.options).onMutate) == null ? void 0 : g.call(
            E,
            e,
            s
          );
          Y !== this.state.context && w(this, de, we).call(this, {
            type: "pending",
            context: Y,
            variables: e,
            isPaused: o
          });
        }
        const M = yield i(this, $e).start();
        return yield (S = (p = i(this, Z).config).onSuccess) == null ? void 0 : S.call(
          p,
          M,
          e,
          this.state.context,
          this,
          s
        ), yield (Q = (R = this.options).onSuccess) == null ? void 0 : Q.call(
          R,
          M,
          e,
          this.state.context,
          s
        ), yield (O = (P = i(this, Z).config).onSettled) == null ? void 0 : O.call(
          P,
          M,
          null,
          this.state.variables,
          this.state.context,
          this,
          s
        ), yield (_ = (D = this.options).onSettled) == null ? void 0 : _.call(
          D,
          M,
          null,
          e,
          this.state.context,
          s
        ), w(this, de, we).call(this, { type: "success", data: M }), M;
      } catch (M) {
        try {
          throw yield (v = (W = i(this, Z).config).onError) == null ? void 0 : v.call(
            W,
            M,
            e,
            this.state.context,
            this,
            s
          ), yield ($ = (k = this.options).onError) == null ? void 0 : $.call(
            k,
            M,
            e,
            this.state.context,
            s
          ), yield (K = (te = i(this, Z).config).onSettled) == null ? void 0 : K.call(
            te,
            void 0,
            M,
            this.state.variables,
            this.state.context,
            this,
            s
          ), yield (N = (le = this.options).onSettled) == null ? void 0 : N.call(
            le,
            void 0,
            M,
            e,
            this.state.context,
            s
          ), M;
        } finally {
          w(this, de, we).call(this, { type: "error", error: M });
        }
      } finally {
        i(this, Z).runNext(this);
      }
    });
  }
}, bt = new WeakMap(), fe = new WeakMap(), Z = new WeakMap(), $e = new WeakMap(), de = new WeakSet(), we = function(e) {
  const r = (s) => {
    switch (e.type) {
      case "failed":
        return j(b({}, s), {
          failureCount: e.failureCount,
          failureReason: e.error
        });
      case "pause":
        return j(b({}, s), {
          isPaused: !0
        });
      case "continue":
        return j(b({}, s), {
          isPaused: !1
        });
      case "pending":
        return j(b({}, s), {
          context: e.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: e.isPaused,
          status: "pending",
          variables: e.variables,
          submittedAt: Date.now()
        });
      case "success":
        return j(b({}, s), {
          data: e.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        });
      case "error":
        return j(b({}, s), {
          data: void 0,
          error: e.error,
          failureCount: s.failureCount + 1,
          failureReason: e.error,
          isPaused: !1,
          status: "error"
        });
    }
  };
  this.state = r(this.state), V.batch(() => {
    i(this, fe).forEach((s) => {
      s.onMutationUpdate(e);
    }), i(this, Z).notify({
      mutation: this,
      type: "updated",
      action: e
    });
  });
}, is);
function bs() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var me, ce, Et, ns, Si = (ns = class extends ut {
  constructor(e = {}) {
    super();
    y(this, me);
    y(this, ce);
    y(this, Et);
    this.config = e, f(this, me, /* @__PURE__ */ new Set()), f(this, ce, /* @__PURE__ */ new Map()), f(this, Et, 0);
  }
  build(e, r, s) {
    const a = new Ri({
      client: e,
      mutationCache: this,
      mutationId: ++Pt(this, Et)._,
      options: e.defaultMutationOptions(r),
      state: s
    });
    return this.add(a), a;
  }
  add(e) {
    i(this, me).add(e);
    const r = Tt(e);
    if (typeof r == "string") {
      const s = i(this, ce).get(r);
      s ? s.push(e) : i(this, ce).set(r, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (i(this, me).delete(e)) {
      const r = Tt(e);
      if (typeof r == "string") {
        const s = i(this, ce).get(r);
        if (s)
          if (s.length > 1) {
            const a = s.indexOf(e);
            a !== -1 && s.splice(a, 1);
          } else s[0] === e && i(this, ce).delete(r);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const r = Tt(e);
    if (typeof r == "string") {
      const s = i(this, ce).get(r), a = s == null ? void 0 : s.find(
        (o) => o.state.status === "pending"
      );
      return !a || a === e;
    } else
      return !0;
  }
  runNext(e) {
    var s, a;
    const r = Tt(e);
    if (typeof r == "string") {
      const o = (s = i(this, ce).get(r)) == null ? void 0 : s.find((u) => u !== e && u.state.isPaused);
      return (a = o == null ? void 0 : o.continue()) != null ? a : Promise.resolve();
    } else
      return Promise.resolve();
  }
  clear() {
    V.batch(() => {
      i(this, me).forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), i(this, me).clear(), i(this, ce).clear();
    });
  }
  getAll() {
    return Array.from(i(this, me));
  }
  find(e) {
    const r = b({ exact: !0 }, e);
    return this.getAll().find(
      (s) => $r(r, s)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((r) => $r(e, r));
  }
  notify(e) {
    V.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((r) => r.state.isPaused);
    return V.batch(
      () => Promise.all(
        e.map((r) => r.continue().catch(ee))
      )
    );
  }
}, me = new WeakMap(), ce = new WeakMap(), Et = new WeakMap(), ns);
function Tt(t) {
  var e;
  return (e = t.options.scope) == null ? void 0 : e.id;
}
var ge, Pe, ie, be, Ee, Ft, ar, as, Oi = (as = class extends ut {
  constructor(e, r) {
    super();
    y(this, Ee);
    y(this, ge);
    y(this, Pe);
    y(this, ie);
    y(this, be);
    f(this, ge, e), this.setOptions(r), this.bindMethods(), w(this, Ee, Ft).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(e) {
    var s;
    const r = this.options;
    this.options = i(this, ge).defaultMutationOptions(e), Dt(this.options, r) || i(this, ge).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: i(this, ie),
      observer: this
    }), r != null && r.mutationKey && this.options.mutationKey && We(r.mutationKey) !== We(this.options.mutationKey) ? this.reset() : ((s = i(this, ie)) == null ? void 0 : s.state.status) === "pending" && i(this, ie).setOptions(this.options);
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || (e = i(this, ie)) == null || e.removeObserver(this);
  }
  onMutationUpdate(e) {
    w(this, Ee, Ft).call(this), w(this, Ee, ar).call(this, e);
  }
  getCurrentResult() {
    return i(this, Pe);
  }
  reset() {
    var e;
    (e = i(this, ie)) == null || e.removeObserver(this), f(this, ie, void 0), w(this, Ee, Ft).call(this), w(this, Ee, ar).call(this);
  }
  mutate(e, r) {
    var s;
    return f(this, be, r), (s = i(this, ie)) == null || s.removeObserver(this), f(this, ie, i(this, ge).getMutationCache().build(i(this, ge), this.options)), i(this, ie).addObserver(this), i(this, ie).execute(e);
  }
}, ge = new WeakMap(), Pe = new WeakMap(), ie = new WeakMap(), be = new WeakMap(), Ee = new WeakSet(), Ft = function() {
  var r, s;
  const e = (s = (r = i(this, ie)) == null ? void 0 : r.state) != null ? s : bs();
  f(this, Pe, j(b({}, e), {
    isPending: e.status === "pending",
    isSuccess: e.status === "success",
    isError: e.status === "error",
    isIdle: e.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  }));
}, ar = function(e) {
  V.batch(() => {
    var r, s, a, o, u, l, h, E;
    if (i(this, be) && this.hasListeners()) {
      const g = i(this, Pe).variables, p = i(this, Pe).context, S = {
        client: i(this, ge),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      (e == null ? void 0 : e.type) === "success" ? ((s = (r = i(this, be)).onSuccess) == null || s.call(
        r,
        e.data,
        g,
        p,
        S
      ), (o = (a = i(this, be)).onSettled) == null || o.call(
        a,
        e.data,
        null,
        g,
        p,
        S
      )) : (e == null ? void 0 : e.type) === "error" && ((l = (u = i(this, be)).onError) == null || l.call(
        u,
        e.error,
        g,
        p,
        S
      ), (E = (h = i(this, be)).onSettled) == null || E.call(
        h,
        void 0,
        e.error,
        g,
        p,
        S
      ));
    }
    this.listeners.forEach((g) => {
      g(i(this, Pe));
    });
  });
}, as), ye, os, Ci = (os = class extends ut {
  constructor(e = {}) {
    super();
    y(this, ye);
    this.config = e, f(this, ye, /* @__PURE__ */ new Map());
  }
  build(e, r, s) {
    var l;
    const a = r.queryKey, o = (l = r.queryHash) != null ? l : or(a, r);
    let u = this.get(o);
    return u || (u = new mi({
      client: e,
      queryKey: a,
      queryHash: o,
      options: e.defaultQueryOptions(r),
      state: s,
      defaultOptions: e.getQueryDefaults(a)
    }), this.add(u)), u;
  }
  add(e) {
    i(this, ye).has(e.queryHash) || (i(this, ye).set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const r = i(this, ye).get(e.queryHash);
    r && (e.destroy(), r === e && i(this, ye).delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    V.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return i(this, ye).get(e);
  }
  getAll() {
    return [...i(this, ye).values()];
  }
  find(e) {
    const r = b({ exact: !0 }, e);
    return this.getAll().find(
      (s) => Lr(r, s)
    );
  }
  findAll(e = {}) {
    const r = this.getAll();
    return Object.keys(e).length > 0 ? r.filter((s) => Lr(e, s)) : r;
  }
  notify(e) {
    V.batch(() => {
      this.listeners.forEach((r) => {
        r(e);
      });
    });
  }
  onFocus() {
    V.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    V.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, ye = new WeakMap(), os), q, _e, Te, it, nt, Fe, at, ot, us, Pi = (us = class {
  constructor(t = {}) {
    y(this, q);
    y(this, _e);
    y(this, Te);
    y(this, it);
    y(this, nt);
    y(this, Fe);
    y(this, at);
    y(this, ot);
    f(this, q, t.queryCache || new Ci()), f(this, _e, t.mutationCache || new Si()), f(this, Te, t.defaultOptions || {}), f(this, it, /* @__PURE__ */ new Map()), f(this, nt, /* @__PURE__ */ new Map()), f(this, Fe, 0);
  }
  mount() {
    Pt(this, Fe)._++, i(this, Fe) === 1 && (f(this, at, ur.subscribe((t) => H(this, null, function* () {
      t && (yield this.resumePausedMutations(), i(this, q).onFocus());
    }))), f(this, ot, At.subscribe((t) => H(this, null, function* () {
      t && (yield this.resumePausedMutations(), i(this, q).onOnline());
    }))));
  }
  unmount() {
    var t, e;
    Pt(this, Fe)._--, i(this, Fe) === 0 && ((t = i(this, at)) == null || t.call(this), f(this, at, void 0), (e = i(this, ot)) == null || e.call(this), f(this, ot, void 0));
  }
  isFetching(t) {
    return i(this, q).findAll(j(b({}, t), { fetchStatus: "fetching" })).length;
  }
  isMutating(t) {
    return i(this, _e).findAll(j(b({}, t), { status: "pending" })).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(t) {
    var r;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (r = i(this, q).get(e.queryHash)) == null ? void 0 : r.state.data;
  }
  ensureQueryData(t) {
    const e = this.defaultQueryOptions(t), r = i(this, q).build(this, e), s = r.state.data;
    return s === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && r.isStaleByTime(De(e.staleTime, r)) && this.prefetchQuery(e), Promise.resolve(s));
  }
  getQueriesData(t) {
    return i(this, q).findAll(t).map(({ queryKey: e, state: r }) => {
      const s = r.data;
      return [e, s];
    });
  }
  setQueryData(t, e, r) {
    const s = this.defaultQueryOptions({ queryKey: t }), a = i(this, q).get(
      s.queryHash
    ), o = a == null ? void 0 : a.state.data, u = oi(e, o);
    if (u !== void 0)
      return i(this, q).build(this, s).setData(u, j(b({}, r), { manual: !0 }));
  }
  setQueriesData(t, e, r) {
    return V.batch(
      () => i(this, q).findAll(t).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, e, r)
      ])
    );
  }
  getQueryState(t) {
    var r;
    const e = this.defaultQueryOptions({ queryKey: t });
    return (r = i(this, q).get(
      e.queryHash
    )) == null ? void 0 : r.state;
  }
  removeQueries(t) {
    const e = i(this, q);
    V.batch(() => {
      e.findAll(t).forEach((r) => {
        e.remove(r);
      });
    });
  }
  resetQueries(t, e) {
    const r = i(this, q);
    return V.batch(() => (r.findAll(t).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      b({
        type: "active"
      }, t),
      e
    )));
  }
  cancelQueries(t, e = {}) {
    const r = b({ revert: !0 }, e), s = V.batch(
      () => i(this, q).findAll(t).map((a) => a.cancel(r))
    );
    return Promise.all(s).then(ee).catch(ee);
  }
  invalidateQueries(t, e = {}) {
    return V.batch(() => {
      var r, s;
      return i(this, q).findAll(t).forEach((a) => {
        a.invalidate();
      }), (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries(
        j(b({}, t), {
          type: (s = (r = t == null ? void 0 : t.refetchType) != null ? r : t == null ? void 0 : t.type) != null ? s : "active"
        }),
        e
      );
    });
  }
  refetchQueries(t, e = {}) {
    var a;
    const r = j(b({}, e), {
      cancelRefetch: (a = e.cancelRefetch) != null ? a : !0
    }), s = V.batch(
      () => i(this, q).findAll(t).filter((o) => !o.isDisabled() && !o.isStatic()).map((o) => {
        let u = o.fetch(void 0, r);
        return r.throwOnError || (u = u.catch(ee)), o.state.fetchStatus === "paused" ? Promise.resolve() : u;
      })
    );
    return Promise.all(s).then(ee);
  }
  fetchQuery(t) {
    const e = this.defaultQueryOptions(t);
    e.retry === void 0 && (e.retry = !1);
    const r = i(this, q).build(this, e);
    return r.isStaleByTime(
      De(e.staleTime, r)
    ) ? r.fetch(e) : Promise.resolve(r.state.data);
  }
  prefetchQuery(t) {
    return this.fetchQuery(t).then(ee).catch(ee);
  }
  fetchInfiniteQuery(t) {
    return t.behavior = zr(t.pages), this.fetchQuery(t);
  }
  prefetchInfiniteQuery(t) {
    return this.fetchInfiniteQuery(t).then(ee).catch(ee);
  }
  ensureInfiniteQueryData(t) {
    return t.behavior = zr(t.pages), this.ensureQueryData(t);
  }
  resumePausedMutations() {
    return At.isOnline() ? i(this, _e).resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return i(this, q);
  }
  getMutationCache() {
    return i(this, _e);
  }
  getDefaultOptions() {
    return i(this, Te);
  }
  setDefaultOptions(t) {
    f(this, Te, t);
  }
  setQueryDefaults(t, e) {
    i(this, it).set(We(t), {
      queryKey: t,
      defaultOptions: e
    });
  }
  getQueryDefaults(t) {
    const e = [...i(this, it).values()], r = {};
    return e.forEach((s) => {
      pt(t, s.queryKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  setMutationDefaults(t, e) {
    i(this, nt).set(We(t), {
      mutationKey: t,
      defaultOptions: e
    });
  }
  getMutationDefaults(t) {
    const e = [...i(this, nt).values()], r = {};
    return e.forEach((s) => {
      pt(t, s.mutationKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  defaultQueryOptions(t) {
    if (t._defaulted)
      return t;
    const e = j(b(b(b({}, i(this, Te).queries), this.getQueryDefaults(t.queryKey)), t), {
      _defaulted: !0
    });
    return e.queryHash || (e.queryHash = or(
      e.queryKey,
      e
    )), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.queryFn === xt && (e.enabled = !1), e;
  }
  defaultMutationOptions(t) {
    return t != null && t._defaulted ? t : j(b(b(b({}, i(this, Te).mutations), (t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey)), t), {
      _defaulted: !0
    });
  }
  clear() {
    i(this, q).clear(), i(this, _e).clear();
  }
}, q = new WeakMap(), _e = new WeakMap(), Te = new WeakMap(), it = new WeakMap(), nt = new WeakMap(), Fe = new WeakMap(), at = new WeakMap(), ot = new WeakMap(), us), Es = z.createContext(
  void 0
), ws = (t) => {
  const e = z.useContext(Es);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, _i = ({
  client: t,
  children: e
}) => (z.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ ls.jsx(Es.Provider, { value: t, children: e })), Rs = z.createContext(!1), Ti = () => z.useContext(Rs);
Rs.Provider;
function Fi() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var Di = z.createContext(Fi()), xi = () => z.useContext(Di), Ai = (t, e) => {
  (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1));
}, Ii = (t) => {
  z.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Mi = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: r,
  query: s,
  suspense: a
}) => t.isError && !e.isReset() && !t.isFetching && s && (a && t.data === void 0 || ds(r, [t.error, s])), ji = (t) => {
  if (t.suspense) {
    const r = (a) => a === "static" ? a : Math.max(a != null ? a : 1e3, 1e3), s = t.staleTime;
    t.staleTime = typeof s == "function" ? (...a) => r(s(...a)) : r(s), typeof t.gcTime == "number" && (t.gcTime = Math.max(
      t.gcTime,
      1e3
    ));
  }
}, ki = (t, e) => t.isLoading && t.isFetching && !e, qi = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, Jr = (t, e, r) => e.fetchOptimistic(t).catch(() => {
  r.clearReset();
});
function Qi(t, e, r) {
  var p, S, R, Q, P;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const s = Ti(), a = xi(), o = ws(), u = o.defaultQueryOptions(t);
  (S = (p = o.getDefaultOptions().queries) == null ? void 0 : p._experimental_beforeQuery) == null || S.call(
    p,
    u
  ), process.env.NODE_ENV !== "production" && (u.queryFn || console.error(
    `[${u.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
  )), u._optimisticResults = s ? "isRestoring" : "optimistic", ji(u), Ai(u, a), Ii(a);
  const l = !o.getQueryCache().get(u.queryHash), [h] = z.useState(
    () => new e(
      o,
      u
    )
  ), E = h.getOptimisticResult(u), g = !s && t.subscribed !== !1;
  if (z.useSyncExternalStore(
    z.useCallback(
      (O) => {
        const D = g ? h.subscribe(V.batchCalls(O)) : ee;
        return h.updateResult(), D;
      },
      [h, g]
    ),
    () => h.getCurrentResult(),
    () => h.getCurrentResult()
  ), z.useEffect(() => {
    h.setOptions(u);
  }, [u, h]), qi(u, E))
    throw Jr(u, h, a);
  if (Mi({
    result: E,
    errorResetBoundary: a,
    throwOnError: u.throwOnError,
    query: o.getQueryCache().get(u.queryHash),
    suspense: u.suspense
  }))
    throw E.error;
  if ((Q = (R = o.getDefaultOptions().queries) == null ? void 0 : R._experimental_afterQuery) == null || Q.call(
    R,
    u,
    E
  ), u.experimental_prefetchInRender && !Ve && ki(E, s)) {
    const O = l ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Jr(u, h, a)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (P = o.getQueryCache().get(u.queryHash)) == null ? void 0 : P.promise
    );
    O == null || O.catch(ee).finally(() => {
      h.updateResult();
    });
  }
  return u.notifyOnChangeProps ? E : h.trackResult(E);
}
function Ss(t, e) {
  return Qi(t, gi);
}
function Ui(t, e) {
  const r = ws(), [s] = z.useState(
    () => new Oi(
      r,
      t
    )
  );
  z.useEffect(() => {
    s.setOptions(t);
  }, [s, t]);
  const a = z.useSyncExternalStore(
    z.useCallback(
      (u) => s.subscribe(V.batchCalls(u)),
      [s]
    ),
    () => s.getCurrentResult(),
    () => s.getCurrentResult()
  ), o = z.useCallback(
    (u, l) => {
      s.mutate(u, l).catch(ee);
    },
    [s]
  );
  if (a.error && ds(s.options.throwOnError, [a.error]))
    throw a.error;
  return j(b({}, a), { mutate: o, mutateAsync: a.mutate });
}
const It = new Pi();
function Bi({ children: t }) {
  return /* @__PURE__ */ ls.jsx(_i, { client: It, children: t });
}
class Ki extends Error {
  constructor(e = "Anima SDK is not initialized") {
    super(e), this.name = "AnimaSDKNotInitializedError";
  }
}
function Mt(t) {
  return t instanceof Error ? !!(t.name === "AnimaError" || Object.prototype.hasOwnProperty.call(t, "__ANIMA_SDK_ERROR")) : !1;
}
const Ni = 5e3;
let ze = null;
function He() {
  return window.anima ? Promise.resolve(window.anima) : ze || (ze = new Promise((t, e) => {
    const r = Date.now(), s = () => {
      if (window.anima) {
        t(window.anima), ze = null;
        return;
      }
      if (Date.now() - r >= Ni) {
        e(new Ki()), ze = null;
        return;
      }
      setTimeout(s, 50);
    };
    s();
  }), ze);
}
const jt = 3;
function Yi(t, e) {
  const { id: r, filters: s } = Li(e), { data: a, error: o, isPending: u } = Ss({
    queryKey: [t, r, s],
    queryFn: () => H(this, null, function* () {
      const h = (yield He()).db[t];
      if (!h)
        throw new Error(`Entity "${t}" not found in the SDK.`);
      return r ? h.findById(r) : h.findMany(e);
    }),
    retry: (l, h) => Mt(h) ? !1 : l < jt
  });
  return {
    data: a,
    error: o,
    isPending: u
  };
}
function Li(t) {
  return typeof t == "string" ? { id: t, filters: void 0 } : { id: void 0, filters: t };
}
function zi(t) {
  const e = Ui({
    mutationFn: (o) => H(this, null, function* () {
      const l = (yield He()).db[t];
      if (!l)
        throw new Error(`Entity "${t}" not found in the SDK.`);
      switch (o.type) {
        case "create":
          return l.create(o.data);
        case "update":
          return l.updateById(o.id, o.data);
        case "remove":
          return l.deleteById(o.id);
      }
    }),
    onSuccess: () => H(this, null, function* () {
      yield It.invalidateQueries({ queryKey: [t] });
    }),
    retry: (o, u) => Mt(u) ? !1 : o < jt
  });
  return {
    create: (o) => H(this, null, function* () {
      return e.mutateAsync({ type: "create", data: o });
    }),
    update: (o, u) => H(this, null, function* () {
      return e.mutateAsync({ type: "update", id: o, data: u });
    }),
    remove: (o) => H(this, null, function* () {
      return e.mutateAsync({ type: "remove", id: o });
    }),
    error: e.error,
    isPending: e.isPending
  };
}
function Gi(t) {
  return {
    query: (r) => H(this, null, function* () {
      const { id: s, filters: a } = $i(r);
      return It.fetchQuery({
        queryKey: [t, s, a],
        queryFn: () => H(this, null, function* () {
          const u = (yield He()).db[t];
          if (!u)
            throw new Error(`Entity "${t}" not found in the SDK.`);
          return s ? u.findById(s) : u.findMany(r);
        }),
        retry: (o, u) => Mt(u) ? !1 : o < jt
      });
    })
  };
}
function $i(t) {
  return typeof t == "string" ? { id: t, filters: void 0 } : { id: void 0, filters: t };
}
function Hi() {
  const { data: t, error: e, isPending: r } = Ss({
    queryKey: ["user"],
    queryFn: () => H(this, null, function* () {
      return (yield He()).user.me();
    }),
    retry: (s, a) => Mt(a) ? !1 : s < jt
  });
  return {
    user: t,
    error: e,
    isPending: r
  };
}
function Ji(t) {
  const { user: e, error: r, isPending: s } = Hi();
  ei(() => {
    if (!(t != null && t.requireAuth))
      return;
    const u = new AbortController();
    function l() {
      return H(this, null, function* () {
        const h = yield He();
        u.signal.aborted || e === null && (console.warn("User is not authenticated, but authentication is required"), h.auth.login(t == null ? void 0 : t.theme));
      });
    }
    return l(), () => {
      u.abort();
    };
  }, [e, JSON.stringify(t)]);
  const a = Qr(() => H(this, null, function* () {
    yield (yield He()).auth.login(t == null ? void 0 : t.theme);
  }), [JSON.stringify(t)]), o = Qr(() => H(this, null, function* () {
    yield (yield He()).auth.logout(), yield It.invalidateQueries({ queryKey: ["user"] });
  }), []);
  return {
    user: e,
    error: r,
    isPending: s,
    isAnonymous: e === null,
    login: a,
    logout: o
  };
}
export {
  Bi as AnimaProvider,
  It as queryClient,
  Ji as useAuth,
  Gi as useLazyQuery,
  zi as useMutation,
  Yi as useQuery,
  Hi as useUser
};
//# sourceMappingURL=index.js.map
